# Phase 3: UX Refinements & Polish - TODO List

This document outlines the tasks required to implement UX refinements and polish the Storied Recipes project, as defined in `spec.md`.

## 1. Pre-generation/Buffering Strategy (Backend Focus)

**Goal:** Improve perceived performance and smoothness of story generation. The backend could return slightly larger chunks of text, or potentially pre-generate the *next* chunk to make subsequent requests faster.

**Actions & Files:**

*   **TODO: Modify `routes/recipes.js` (and potentially `services/llmService.js` and `services/cacheService.js`):**
    *   **Purpose:** Adjust story continuation logic for better buffering and implement proactive caching.
    *   **Content:**
        *   **DONE:** Increasing the amount of text generated by the LLM per `/continue` request (system prompt in `services/llmService.js` updated).
        *   **DONE (Proactive Caching):**
            *   **Cache Key Strategy:** Changed to `recipe:{recipeId}:segment:{segmentNumber}`.
            *   **Frontend (`public/js/recipe.js`):**
                *   Sends `segmentNumber` (for the requested segment) and `context` to the `/continue` endpoint.
                *   Receives `nextSegmentNumber` from the backend to use for the subsequent request.
                *   Initial `segmentNumber` (for the first call to `/continue`) is set to 1, informed by the `/initial` endpoint.
            *   **Backend (`routes/recipes.js`):**
                *   `/initial` endpoint now returns `nextSegmentNumber: 1`.
                *   `/continue` endpoint uses `segmentNumber` for the cache key of the requested segment.
                *   After serving the requested segment, it asynchronously (fire-and-forget) generates the *next* segment (`segmentNumber + 1`) using the current segment's content as context.
                *   This proactively generated segment is stored in Redis with key `recipe:{recipeId}:segment:{segmentNumber + 1}`.
                *   The response to the client includes the current `continuation` and `nextSegmentNumber` (which is `segmentNumber + 1`).

**Testing:**

*   **DONE:** Verify that the `/api/recipe/{recipe_id}/continue` endpoint returns appropriately sized text chunks if changed.
*   **DONE:** Observe frontend behavior: Does the story flow more smoothly with larger chunks? Are there fewer noticeable pauses?
*   **DONE:** If proactive caching is implemented:
    *   Monitor LLM calls to confirm that some `/continue` requests are served directly from cache due to pre-generation.
    *   Check Redis to see pre-generated segments.
    *   Measure response times for `/continue` requests to see if pre-generation improves them.

## 2. Story Coherence Tuning (SKIPPED)

**Goal:** Optimize the balance between story coherence, LLM input limits, and cost by adjusting the context sent to the LLM.

**Decision:** Skipped as current behavior is deemed good enough.

**Original Actions & Files (For Reference):**

*   **Modify `public/js/recipe.js`:**
    *   **Purpose:** Adjust client-side context length.
    *   **Content:**
        *   Experiment with the `CHARS_FOR_CONTEXT` constant.
*   **Modify `routes/recipes.js` (and `services/llmService.js`):**
    *   **Purpose:** Adapt backend to potentially handle different context lengths or implement more sophisticated context management.
    *   **Content:**
        *   Ensure the backend correctly uses the full context provided by the client.
        *   **(Advanced/Optional):** Backend context summarization.

**Original Testing (For Reference):**

*   For various `CHARS_FOR_CONTEXT` values:
    *   Generate very long stories.
    *   Evaluate narrative coherence, consistency.
    *   Note degradation in LLM response time or quality.
*   If backend context summarization is implemented, verify its effectiveness.

## 3. Loading Indicators and Error Handling (Frontend) (SKIPPED)

**Goal:** Provide better user feedback during content loading and in case of API or LLM errors.

**Decision:** Skipped as current behavior is deemed acceptable for now.

**Original Actions & Files (For Reference):**

*   **Modify `public/js/recipe.js`:**
    *   **Purpose:** Implement UI updates for loading and error states.
    *   **Content:**
        *   Display loading indicators during `fetchMoreStory`.
        *   Append user-friendly error messages in `catch` blocks.
*   **Modify `public/css/style.css`:**
    *   **Purpose:** Style loading indicators and error messages.
*   **Modify `public/recipe.html` (Optional):**
    *   **Purpose:** Add a dedicated element for status messages.

**Original Testing (For Reference):**

*   Verify loading indicator appearance and disappearance.
*   Simulate API errors and verify display of user-friendly messages.
*   Check styling of indicators and error messages.

## 4. Smooth Scrolling Refinements

**Goal:** Ensure scrolling is as smooth and non-jarring as possible, especially during word-by-word rendering. Address the case where a user scrolls up while new text is being rendered.

**Actions & Files:**

*   **DONE: Modify `public/js/recipe.js`:**
    *   **Purpose:** Improve scroll behavior during rendering, especially when the user scrolls up.
    *   **Content:**
        *   In `renderStorySegmentWordByWord`:
            *   Defined `AUTOSCROLL_BOTTOM_THRESHOLD` (e.g., 250 pixels).
            *   **User Scroll-Up Handling Implemented:**
                *   Before each call to `paragraphElement.scrollIntoView({ block: 'end', behavior: 'auto' });` during word rendering, a check is performed:
                  `const isUserNearBottom = (window.scrollY + window.innerHeight) >= (document.body.offsetHeight - AUTOSCROLL_BOTTOM_THRESHOLD);`
                *   The `scrollIntoView` is only called if `isUserNearBottom` is true.
                *   This effectively disables automatic scrolling if the user has scrolled up away from the bottom of the content, preventing the page from "fighting" their scroll.
                *   Automatic scrolling resumes if the user scrolls back down into the threshold zone.

**Testing:**

*   **TODO:** Vigorously test scrolling up and down while new story segments are being rendered word-by-word.
*   **TODO:** Verify that if the user scrolls up, the automatic scrolling pauses and does not immediately pull their view back down.
*   **TODO:** Verify that automatic scrolling resumes correctly if the user scrolls back to the bottom or when new, subsequent segments are loaded.
*   **TODO:** Test on different browsers for consistent behavior.

## 5. (Optional) Recipe Index Page

**Goal:** Create a simple page to list available recipes and allow users to navigate to them.

**Actions & Files:**

*   **TODO: Create `public/index.html`:**
    *   **Purpose:** Main page for listing recipes.
    *   **Content:** Basic HTML structure. Include a title like "Storied Recipes" and an unordered list (`<ul>`) where recipe links will go. Link to `index.js` and a CSS file.
*   **TODO: Create `public/js/index.js`:**
    *   **Purpose:** Fetch and display the list of recipes.
    *   **Content:**
        *   On `DOMContentLoaded`, fetch data from a new `/api/recipes` endpoint.
        *   For each recipe in the response (e.g., `{id: "recipe-id", title: "Recipe Title"}`), create an `<li>` with an `<a>` tag pointing to `recipe.html?id={recipe_id}`.
        *   Append these list items to the `<ul>` in `index.html`.
*   **TODO: Modify `server.js` (or a new `routes/index.js` and mount it):**
    *   **Purpose:** Add an endpoint to serve the list of recipes.
    *   **Content:**
        *   Define a `GET /api/recipes` endpoint.
        *   This endpoint should read the `data/recipes/` directory, parse each JSON file to get its `id` and `title`, and return an array of these objects.
*   **TODO: Modify `public/js/recipe.js`:**
    *   **Purpose:** Make the recipe page load a recipe based on a URL parameter.
    *   **Content:**
        *   At the beginning of the `DOMContentLoaded` listener:
            *   Get the `id` from `URLSearchParams` (e.g., `new URLSearchParams(window.location.search).get('id')`).
            *   If an `id` is present, use it for `RECIPE_ID` instead of the hardcoded one.
            *   If no `id` is present, either default to a specific recipe, show an error message, or redirect to `index.html`.
*   **TODO: Create or Modify CSS (`public/css/style.css` or a new `public/css/index.css`):**
    *   **Purpose:** Style the `index.html` page.

**Testing:**

*   **TODO:** Verify the new `/api/recipes` endpoint correctly returns a list of available recipes (IDs and titles).
*   **TODO:** Open `public/index.html` (or `/` if server configured to serve it as default). Verify it lists all recipes from the `data/recipes/` directory.
*   **TODO:** Click on a recipe link from `index.html`. Verify it navigates to `recipe.html?id={recipe_id}` and that the correct recipe's title and initial story are loaded.
*   **TODO:** Test accessing `recipe.html` without an `id` parameter – verify the chosen fallback behavior (default recipe, error, or redirect).
*   **TODO:** Test accessing `recipe.html` with an invalid/non-existent `id` – verify graceful error handling (e.g., "Recipe not found" message).

---

This completes the plan for Phase 3. Each step should be tested thoroughly.
