# Phase 3: UX Refinements & Polish - TODO List

This document outlines the tasks required to implement UX refinements and polish the Storied Recipes project, as defined in `spec.md`.

## 1. Pre-generation/Buffering Strategy (Backend Focus)

**Goal:** Improve perceived performance and smoothness of story generation. The backend could return slightly larger chunks of text, or potentially pre-generate the *next* chunk to make subsequent requests faster.

**Actions & Files:**

*   **TODO: Modify `routes/recipes.js` (and potentially `services/llmService.js` and `services/cacheService.js`):**
    *   **Purpose:** Adjust story continuation logic for better buffering.
    *   **Content:**
        *   **IN PROGRESS:** Increasing the amount of text generated by the LLM per `/continue` request. The system prompt in `services/llmService.js` has been updated to ask the LLM to "Aim for a continuation of about 3 to 4 sentences or a short paragraph."
        *   **(Advanced/Optional):** Explore proactive caching: After fulfilling a `/continue` request, the backend could asynchronously generate the *next* segment and store it in Redis. The key for this pre-generated segment should be predictable by the next `/continue` request.
            *   This would require careful cache key design (e.g., based on recipe ID and segment number/cumulative word count).

**Testing:**

*   **TODO:** Verify that the `/api/recipe/{recipe_id}/continue` endpoint returns appropriately sized text chunks if changed.
*   **TODO:** Observe frontend behavior: Does the story flow more smoothly with larger chunks? Are there fewer noticeable pauses?
*   **TODO:** If proactive caching is implemented:
    *   Monitor LLM calls to confirm that some `/continue` requests are served directly from cache due to pre-generation.
    *   Check Redis to see pre-generated segments.
    *   Measure response times for `/continue` requests to see if pre-generation improves them.

## 2. Story Coherence Tuning

**Goal:** Optimize the balance between story coherence, LLM input limits, and cost by adjusting the context sent to the LLM.

**Actions & Files:**

*   **TODO: Modify `public/js/recipe.js`:**
    *   **Purpose:** Adjust client-side context length.
    *   **Content:**
        *   Experiment with the `CHARS_FOR_CONTEXT` constant. Try increasing it (e.g., to 1500, 2000 characters) and decreasing it (e.g., to 500 characters).
*   **TODO: Modify `routes/recipes.js` (and `services/llmService.js`):**
    *   **Purpose:** Adapt backend to potentially handle different context lengths or implement more sophisticated context management.
    *   **Content:**
        *   Ensure the backend correctly uses the full context provided by the client.
        *   **(Advanced/Optional):** If very long contexts become problematic for the LLM, consider backend strategies like summarizing earlier parts of the story to maintain relevance while fitting within token limits.

**Testing:**

*   **TODO:** For various `CHARS_FOR_CONTEXT` values:
    *   Generate very long stories (e.g., scroll for several minutes).
    *   Read through the generated stories to evaluate their narrative coherence, consistency, and whether they "remember" earlier plot points.
    *   Note any degradation in LLM response time or quality with very long contexts.
*   **TODO:** If backend context summarization is implemented, verify its effectiveness.

## 3. Loading Indicators and Error Handling (Frontend)

**Goal:** Provide better user feedback during content loading and in case of API or LLM errors.

**Actions & Files:**

*   **TODO: Modify `public/js/recipe.js`:**
    *   **Purpose:** Implement UI updates for loading and error states.
    *   **Content:**
        *   In `fetchMoreStory`:
            *   When `isFetchingMoreStory` is set to `true`, display a subtle loading indicator. This could be a small text message (e.g., "The storyteller is scribbling furiously...") or a simple animated spinner appended to `story-content` or a dedicated status element.
            *   When new content is received or an error occurs (and `isFetchingMoreStory` becomes `false`), remove/hide the loading indicator.
        *   In the `catch` blocks of `fetchInitialData` and `fetchMoreStory`:
            *   Instead of just `console.error`, append a user-friendly error message to `story-content`. For example: "Oh dear, the ink seems to have run dry! Please try scrolling again in a moment."
            *   Ensure these messages are clearly distinct from the story text.
*   **TODO: Modify `public/css/style.css`:**
    *   **Purpose:** Style the new loading indicators and error messages.
    *   **Content:** Add CSS rules for `.loading-indicator`, `.error-message`, etc.
*   **TODO: Modify `public/recipe.html` (Optional):**
    *   **Purpose:** Add a dedicated element for status messages if preferred.
    *   **Content:** Could add `<div id="status-messages"></div>` where loading/error messages are placed.

**Testing:**

*   **TODO:** Verify that the loading indicator appears briefly when scrolling triggers a new fetch and disappears once content starts rendering or an error is shown.
*   **TODO:** Simulate API errors for `/initial` and `/continue` endpoints (e.g., by temporarily stopping the backend server or modifying an endpoint to return a 500 error).
    *   Verify that user-friendly error messages are displayed in `story-content`.
    *   Verify that the application remains usable (e.g., user can try scrolling again).
*   **TODO:** Check styling of loading indicators and error messages.

## 4. Smooth Scrolling Refinements

**Goal:** Ensure scrolling is as smooth and non-jarring as possible, especially during word-by-word rendering. Address the case where a user scrolls up while new text is being rendered.

**Actions & Files:**

*   **TODO: Modify `public/js/recipe.js`:**
    *   **Purpose:** Improve scroll behavior during rendering.
    *   **Content:**
        *   In `renderStorySegmentWordByWord`:
            *   The current `paragraphElement.scrollIntoView({ block: 'end', behavior: 'auto' });` is a good start.
            *   **User Scroll-Up Handling:**
                *   Before calling `scrollIntoView`, check if the user has manually scrolled up significantly from the bottom of the content.
                *   One way: Store `window.scrollY + window.innerHeight` before starting to render a word. Just before rendering the next word, if the current `window.scrollY + window.innerHeight` is much less than `document.body.offsetHeight - SOME_THRESHOLD` (e.g., user is not near the bottom anymore), then temporarily disable the automatic `scrollIntoView`.
                *   Resume automatic scrolling if the user scrolls back down near the bottom, or when a new segment fetch is initiated.
                *   This prevents "fighting" the user if they scroll up to re-read.

**Testing:**

*   **TODO:** Vigorously test scrolling up and down while new story segments are being rendered word-by-word.
*   **TODO:** Verify that if the user scrolls up, the automatic scrolling pauses and does not immediately pull their view back down.
*   **TODO:** Verify that automatic scrolling resumes correctly if the user scrolls back to the bottom or when new, subsequent segments are loaded.
*   **TODO:** Test on different browsers for consistent behavior.

## 5. (Optional) Recipe Index Page

**Goal:** Create a simple page to list available recipes and allow users to navigate to them.

**Actions & Files:**

*   **TODO: Create `public/index.html`:**
    *   **Purpose:** Main page for listing recipes.
    *   **Content:** Basic HTML structure. Include a title like "Storied Recipes" and an unordered list (`<ul>`) where recipe links will go. Link to `index.js` and a CSS file.
*   **TODO: Create `public/js/index.js`:**
    *   **Purpose:** Fetch and display the list of recipes.
    *   **Content:**
        *   On `DOMContentLoaded`, fetch data from a new `/api/recipes` endpoint.
        *   For each recipe in the response (e.g., `{id: "recipe-id", title: "Recipe Title"}`), create an `<li>` with an `<a>` tag pointing to `recipe.html?id={recipe_id}`.
        *   Append these list items to the `<ul>` in `index.html`.
*   **TODO: Modify `server.js` (or a new `routes/index.js` and mount it):**
    *   **Purpose:** Add an endpoint to serve the list of recipes.
    *   **Content:**
        *   Define a `GET /api/recipes` endpoint.
        *   This endpoint should read the `data/recipes/` directory, parse each JSON file to get its `id` and `title`, and return an array of these objects.
*   **TODO: Modify `public/js/recipe.js`:**
    *   **Purpose:** Make the recipe page load a recipe based on a URL parameter.
    *   **Content:**
        *   At the beginning of the `DOMContentLoaded` listener:
            *   Get the `id` from `URLSearchParams` (e.g., `new URLSearchParams(window.location.search).get('id')`).
            *   If an `id` is present, use it for `RECIPE_ID` instead of the hardcoded one.
            *   If no `id` is present, either default to a specific recipe, show an error message, or redirect to `index.html`.
*   **TODO: Create or Modify CSS (`public/css/style.css` or a new `public/css/index.css`):**
    *   **Purpose:** Style the `index.html` page.

**Testing:**

*   **TODO:** Verify the new `/api/recipes` endpoint correctly returns a list of available recipes (IDs and titles).
*   **TODO:** Open `public/index.html` (or `/` if server configured to serve it as default). Verify it lists all recipes from the `data/recipes/` directory.
*   **TODO:** Click on a recipe link from `index.html`. Verify it navigates to `recipe.html?id={recipe_id}` and that the correct recipe's title and initial story are loaded.
*   **TODO:** Test accessing `recipe.html` without an `id` parameter – verify the chosen fallback behavior (default recipe, error, or redirect).
*   **TODO:** Test accessing `recipe.html` with an invalid/non-existent `id` – verify graceful error handling (e.g., "Recipe not found" message).

---

This completes the plan for Phase 3. Each step should be tested thoroughly.
